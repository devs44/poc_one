"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsRunner = void 0;
const fs = require("fs");
const moment = require("moment");
const path = require("path");
const logger_1 = require("./logger");
class CommandsRunner {
    constructor({ directoryWithScripts, dateFormat = 'YYYYMMDDHHmm', driver, logger = new logger_1.ColoredLogger() }) {
        this.driver = driver;
        this.logger = logger;
        this.directoryWithScripts = directoryWithScripts;
        this.dateFormat = dateFormat;
        this.commands = {
            init: {
                description: 'Initialized database for migrations',
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.doInit();
                }),
                skipInit: true,
            },
            fake: {
                description: `Fakes the migrations, marks that files in ${this.directoryWithScripts} are executed successfully`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.fakeAllScripts();
                })
            },
            list: {
                description: `Show all unapplied migrations from ${this.directoryWithScripts}`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.printNewMigrations();
                })
            },
            migrate: {
                description: `Installs all new updates from ${this.directoryWithScripts}`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.findAndRunMigrations(false);
                })
            },
            forceMigrate: {
                description: `Installs all new updates from ${this.directoryWithScripts}. If one migration fails it goes to another one.`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield yield this.findAndRunMigrations(true);
                })
            },
            resolve: {
                description: `Marks all failed migrations as resolved`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.resolveAllMigrations();
                })
            },
            getFailed: {
                description: `Show all failed migrations`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    yield this.getFailedMigrations();
                })
            },
            help: {
                description: `Prints help`,
                run: () => __awaiter(this, void 0, void 0, function* () {
                    this.printHelp();
                }),
                skipInit: true,
            }
        };
    }
    runSql(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`runSql: '${sql}'; arguments: [\'${params.join('\',\'')}']`);
            const result = yield this.driver.query(sql, params);
            if (result) {
                throw Error(result);
            }
        });
    }
    readSql(sql, params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`readSql: '${sql}'; arguments: [\'${params.join('\',\'')}']`);
            const result = yield this.driver.readQuery(sql, params);
            if (result.error) {
                throw Error(result.error);
            }
            return result.rows;
        });
    }
    checkIfExists() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info('Checking if migration table exists');
            const result = yield this.readSql(this.driver.isInitedSql(), []);
            const isExists = result.length > 0;
            this.logger.info(isExists ? 'Migration table exists' : `Migration table doesn't exist`);
            return isExists;
        });
    }
    doInit() {
        return __awaiter(this, void 0, void 0, function* () {
            const exists = yield this.checkIfExists();
            if (!exists) {
                this.logger.info(`Creating migration table...`);
                yield this.runSql(this.driver.createTableSql(), []);
                yield this.runSql(this.driver.createUniqueTableIndex(), []);
                this.logger.success('DB has been successfully initialized');
            }
            else {
                this.logger.info('Db already exists');
            }
        });
    }
    getScriptStr(script) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = path.join(this.directoryWithScripts, script);
            return new Promise((resolve, reject) => {
                fs.readFile(filePath, { encoding: 'utf-8' }, (err, data) => {
                    if (err) {
                        reject(err.message);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        });
    }
    getFilesMigrations(exclude) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                fs.readdir(this.directoryWithScripts, (err, files) => {
                    if (err) {
                        reject(err.message);
                    }
                    else {
                        if (exclude) {
                            files = files.filter(e => exclude.findIndex(f => f.name === e) < 0);
                        }
                        let result = [];
                        files.forEach(e => result.push({ name: e, created: moment(e, this.dateFormat).toDate() }));
                        result =
                            result.sort((a, b) => a.created.getTime() - b.created.getTime());
                        resolve(result);
                    }
                });
            });
        });
    }
    runScript(fileName, created, failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = yield this.getScriptStr(fileName);
            this.logger.infoParams('Executing {} ...', fileName);
            const error = yield this.driver.executeMultipleStatements(query);
            yield this.markExecuted(fileName, created, error);
            if (error && !failSilently) {
                throw Error(error);
            }
        });
    }
    markExecuted(fileName, created, migrationErr) {
        return __awaiter(this, void 0, void 0, function* () {
            if (migrationErr) {
                this.logger.infoParamsColor('Migration {} failed with error {}', {
                    param: fileName,
                    color: this.logger.colors.FgCyan
                }, { param: migrationErr, color: this.logger.colors.FgRed });
            }
            else {
                this.logger.infoParams('Migration {} succeeded', fileName);
            }
            yield this.runSql(this.driver.markExecuted(), [fileName, created, migrationErr]);
        });
    }
    findNewMigrations(failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            const completedMigrations = yield this.getCompletedMigrations(failSilently);
            return yield this.getFilesMigrations(completedMigrations);
        });
    }
    getDbMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.readSql(this.driver.getDbMigrations(), []);
        });
    }
    getCompletedMigrations(failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.getDbMigrations();
            if (!failSilently) {
                res.forEach(r => {
                    if (r.error_if_happened) {
                        throw Error(`Can't start migrations while having a failed one. Run 'resolve' first. Error details: \n${JSON.stringify(r)}`);
                    }
                });
            }
            return res;
        });
    }
    runMigrations(allScript, failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < allScript.length; i++) {
                yield this.runScript(allScript[i].name, allScript[i].created, failSilently);
            }
            this.logger.success('Migrations finished');
        });
    }
    markExecutedAll(allScript) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < allScript.length; i++) {
                yield this.markExecuted(allScript[i].name, allScript[i].created, null);
            }
            this.logger.info('All scripts has been marked as executed');
        });
    }
    getFailedMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            const rows = yield this.readSql(this.driver.getFailedMigrations(), []);
            if (rows.length === 0) {
                this.logger.info('No failed migrations found');
            }
            else {
                this.logger.info(`Found ${rows.length} failed migrations, they will be flagged as resolved:`);
                let result = '';
                rows.forEach(e => {
                    result += ` - ${e.name}:\n   Error: ${e.error_if_happened}\n   Ran on: ${e.run_on}\n`;
                });
                this.logger.info(result);
            }
            return rows.length;
        });
    }
    resolveAllMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            const found = yield this.getFailedMigrations();
            if (found) {
                yield this.runSql(this.driver.removeAllMigrations(), []);
                this.logger.info(`${found} migration(s) marked as resolved`);
            }
        });
    }
    run(command) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Running command ${command}`);
            const c = this.commands[command];
            if (c) {
                if (!c.skipInit) {
                    const inited = yield this.checkIfExists();
                    if (!inited) {
                        throw Error('Db is not initialized');
                    }
                }
                yield c.run();
            }
            else {
                this.printHelp();
                throw Error(`Invalid command ${command}`);
            }
        });
    }
    printHelp() {
        let des = '';
        Object.keys(this.commands).forEach(key => {
            des += `${this.logger.colors.FgCyan}${key}${this.logger.colors.Reset}: ${this.commands[key].description}\n`;
        });
        this.logger.info(`Available commands are: \n${des}`);
    }
    findAndRunMigrations(failSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            const newMigrations = yield this.findNewMigrations(failSilently);
            this.printMigrations(newMigrations);
            yield this.runMigrations(newMigrations, failSilently);
        });
    }
    fakeAllScripts() {
        return __awaiter(this, void 0, void 0, function* () {
            const migrations = yield this.findNewMigrations(false);
            this.printMigrations(migrations);
            yield this.markExecutedAll(migrations);
        });
    }
    printMigrations(migrations) {
        if (migrations.length > 0) {
            this.logger.info(`New migrations found: \n  - ${migrations.map(e => e.name).join('\n  - ')}`);
        }
        else {
            this.logger.info('No new migrations are available');
        }
    }
    printNewMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.findNewMigrations(false);
            this.printMigrations(res);
        });
    }
}
exports.CommandsRunner = CommandsRunner;
//# sourceMappingURL=commands.runner.js.map